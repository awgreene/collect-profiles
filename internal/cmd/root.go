package cmd

import (
	"bytes"
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/awgreene/collect-profiles/internal/pkg/action"
	"github.com/awgreene/collect-profiles/internal/pkg/log"
	"github.com/awgreene/collect-profiles/internal/version"
)

const (
	profileConfigMapLabelKey = "olm.openshift.io/pprof"
	disabled                 = "disabled"
)

var (
	rootCmd = newCmd()

	// Used for flags
	namespace   string
	configPath  string
	tlsCertPath string
)

func init() {
	rootCmd.PersistentFlags().StringVarP(&namespace, "namespace", "n", "default", "The Kubernetes namespace where the generated configMaps should exist. Defaults to \"default\".")
	rootCmd.MarkFlagRequired("namespace")
	rootCmd.PersistentFlags().StringVarP(&configPath, "config-path", "c", "/etc/config/config.yaml", "The path to the collect-profiles configuration file.")
	rootCmd.MarkFlagRequired("config-file")
	rootCmd.PersistentFlags().StringVarP(&tlsCertPath, "tls-cert-path", "", "/etc/pki/tls/certs/", "The path to the tls cert used by the client making https requests against the pprof endpoints.")
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		log.Fatal(err)
	}
}

func getTruePointer() *bool {
	trueBool := true
	return &trueBool
}

func newCmd() *cobra.Command {
	var cfg action.Configuration
	return &cobra.Command{
		Use:   "collect-profiles endpoint:argument",
		Short: "Retrieve the pprof data from an endpoint and stores it in a configMap",
		Long: `The collect-profiles command makes https requests against pprof endpoints
		provided as arguments and stores that information in immutable configMaps.`,
		Version: version.Version,
		PersistentPreRunE: func(*cobra.Command, []string) error {
			return cfg.Load()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			context := context.TODO()
			if len(args) < 1 {
				return fmt.Errorf("must specify endpoint")
			}

			// check if disabled
			file, err := os.Open(filepath.Join(configPath, disabled))
			if err != nil {
				return err
			}
			defer file.Close()

			dat, err := ioutil.ReadFile(filepath.Join(configPath, disabled))
			if err != nil {
				return err
			}

			if strings.ToLower(string(dat)) == "true" {
				klog.Infof("CronJob disabled, exiting")
				return nil
			}

			validatedArguments := make([]*argument, len(args))
			for i, arg := range args {
				a, err := newArgument(arg)
				if err != nil {
					return err
				}
				validatedArguments[i] = a
			}

			// Get existing configmaps
			existingConfigMaps := &corev1.ConfigMapList{}
			if err := cfg.Client.List(context, existingConfigMaps, client.InNamespace(namespace), client.HasLabels{profileConfigMapLabelKey}); err != nil {
				return err
			}

			newestConfigMaps, expiredConfigMaps := seperateConfigMapsIntoNewestAndExpired(existingConfigMaps.Items)

			// Attempt to delete all but the newest configMaps generated by this job
			errs := []error{}
			for _, cm := range expiredConfigMaps {
				if err := cfg.Client.Delete(context, &cm); err != nil {
					errs = append(errs, err) // log the delete error
					continue
				}
				klog.Infof("Successfully deleted configMap %s/%s", cm.GetNamespace(), cm.GetName())
			}

			// If a delete call failed, abort to avoid creating new configMaps
			if len(errs) != 0 {
				return fmt.Errorf("error deleting expired pprof configMaps: %v", errs)
			}

			cert, err := tls.LoadX509KeyPair(filepath.Join(tlsCertPath, corev1.TLSCertKey), filepath.Join(tlsCertPath, corev1.TLSPrivateKeyKey))
			if err != nil {
				return err
			}

			httpClient := http.Client{
				Transport: &http.Transport{
					TLSClientConfig: &tls.Config{
						InsecureSkipVerify: true,
						Certificates:       []tls.Certificate{cert},
					},
				},
			}

			// Track successfully created configMaps by generateName for each endpoint being scrapped.
			createdCM := map[string]struct{}{}

			for _, a := range validatedArguments {
				response, err := httpClient.Do(&http.Request{
					Method: http.MethodGet,
					URL:    a.endpoint,
				})
				if err != nil {
					klog.Errorf("error reading from pprof endpoint %s: %v", a.endpoint.String(), err)
					continue
				}
				if response.StatusCode != http.StatusOK {
					klog.Errorf("%s responded with %d status code instead of %s", a.endpoint, response.StatusCode, http.StatusOK)
					continue
				}

				var b bytes.Buffer
				if _, err := io.Copy(&b, response.Body); err != nil {
					klog.Errorf("error reading response body: %v", err)
					continue
				}

				cm := &corev1.ConfigMap{
					ObjectMeta: metav1.ObjectMeta{
						GenerateName: a.generateName,
						Namespace:    namespace,
						Labels: map[string]string{
							profileConfigMapLabelKey: "",
						},
					},
					Immutable: getTruePointer(),
					BinaryData: map[string][]byte{
						"profile.pb.gz": b.Bytes(),
					},
				}

				if err := cfg.Client.Create(context, cm); err != nil {
					klog.Error("error creating ConfigMap: %v", err)
					continue
				}
				klog.Infof("Successfully created configMap %s/%s", cm.GetNamespace(), cm.GetName())
				createdCM[a.generateName] = struct{}{}
			}

			// Delete the configMaps which are no longer the newest
			for _, cm := range newestConfigMaps {
				// Don't delete ConfigMaps that were not replaced
				// Also prevents deletes of configMaps with generateNames not included in command.
				if _, ok := createdCM[cm.GenerateName]; !ok {
					continue
				}
				if err := cfg.Client.Delete(context, &cm); err != nil {
					errs = append(errs, err)
					continue
				}
				klog.Infof("Successfully deleted configMap %s/%s", cm.GetNamespace(), cm.GetName())
			}

			if len(errs) != 0 {
				return fmt.Errorf("error deleting existing pprof configMaps: %v", errs)
			}
			return nil
		},
	}
}

func seperateConfigMapsIntoNewestAndExpired(configMaps []corev1.ConfigMap) (newestCMs []corev1.ConfigMap, expiredCMs []corev1.ConfigMap) {
	// Group ConfigMaps by GenerateName
	newestConfigMaps := map[string]corev1.ConfigMap{}
	for _, cm := range configMaps {
		if _, ok := newestConfigMaps[cm.GenerateName]; !ok {
			newestConfigMaps[cm.GenerateName] = cm
			continue
		}
		if cm.CreationTimestamp.After(newestConfigMaps[cm.GenerateName].CreationTimestamp.Time) {
			newestConfigMaps[cm.GenerateName], cm = cm, newestConfigMaps[cm.GenerateName]
		}
		expiredCMs = append(expiredCMs, cm)
	}

	for _, v := range newestConfigMaps {
		newestCMs = append(newestCMs, v)
	}

	return newestCMs, expiredCMs
}

type argument struct {
	generateName string
	endpoint     *url.URL
}

func newArgument(s string) (*argument, error) {
	splitStrings := strings.SplitN(s, ":", 2)
	if len(splitStrings) != 2 {
		return nil, fmt.Errorf("Error")
	}

	endpoint, err := url.Parse(splitStrings[1])
	if err != nil {
		return nil, err
	}

	if strings.ToLower(endpoint.Scheme) != "https" {
		return nil, fmt.Errorf("URL Scheme must be HTTPS")
	}

	arg := &argument{
		generateName: splitStrings[0],
		endpoint:     endpoint,
	}

	return arg, nil
}
